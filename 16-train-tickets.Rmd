```{r libraries, echo = FALSE, message = FALSE}
library(dplyr)
library(tidyr)
library(intervals)
library(stringr)
library(purrr)
```

```{r data.loading, echo = FALSE}
ranges <-
    pipe("perl < 16-input -ne '
     BEGIN { print join(q(,), qw(field from1 to1 from2 to2)), qq(\\n) };
     exit unless my @fields = m/(.*?): (\\d+)-(\\d+) or (\\d+)-(\\d+)/;
     print join(q(,), @fields), qq(\\n)'") %>%
    read.csv(header = TRUE) %>%
    pivot_longer(-c(field),
                 names_pattern = '^(from|to)',
                 names_to = c(".value"))

tickets <- pipe("perl < 16-input -ne 'BEGIN { $_ = <> until m/nearby tickets/; } print'") %>%
    read.csv(header = FALSE) %>%
    tibble
```

# First question

Estimate rate of false tickets (those that have at
least one completely aberrant number)

```{r q1, echo = FALSE, message = FALSE}
intervals_Z <- function(from_v, to_v) {
    Intervals_full(c(from_v, to_v), type = "Z") %>%
        intervals::reduce()
}

allowed.values <- intervals_Z(ranges$from, ranges$to)

if (! exists("%within%")) {
    `%within%` <- function (a, b) standardGeneric("%within%")
}

setMethod("%within%", c(a = "numeric", b = "Intervals_full"),
          function(a, b) {  ## Vectorized over a *only*

              ## https://stackoverflow.com/a/7660073/435004
              inwhich <- function(indices, .length)
                  is.element(seq_len(.length), indices)

              Intervals_full(c(a, a), type = "Z") %>%
                  interval_included(from = b) %>%
                  c %>% inwhich(length(a))
          })

stopifnot(identical(
    c(TRUE, TRUE, FALSE),
    c(1, 0, 3) %within% intervals_Z(0, 2)))

bogons <-
    tickets %>%
    mutate(across(everything(),
                  ~ ifelse(.x %within% allowed.values, NA, .x))) %>%
    pivot_longer(everything()) %>%
    filter(! is.na(value))
```

The “ticket scanning error rate” (which is actually not an error rate
at all), is `r bogons$value %>% sum`
