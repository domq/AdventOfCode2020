```{r libraries, echo = FALSE, message = FALSE}
library(dplyr)
library(tidyr)
library(intervals)
library(stringr)
library(purrr)
```

```{r data.loading, echo = FALSE}
ranges <-
    pipe("perl < 16-input -ne '
     BEGIN { print join(q(,), qw(field from1 to1 from2 to2)), qq(\\n) };
     exit unless my @fields = m/(.*?): (\\d+)-(\\d+) or (\\d+)-(\\d+)/;
     print join(q(,), @fields), qq(\\n)'") %>%
    read.csv(header = TRUE) %>%
    tibble

tickets <- pipe("perl < 16-input -ne 'BEGIN { $_ = <> until m/nearby tickets/; } print'") %>%
    read.csv(header = FALSE) %>%
    tibble
```

# First question

Estimate rate of false tickets (those that have at
least one completely aberrant number)

```{r q1, echo = FALSE, message = FALSE}
intervals_Z <- function(from_v, to_v) {
    Intervals_full(c(from_v, to_v), type = "Z") %>%
        intervals::reduce()
}

allowed.values <- interval_union(c(
    intervals_Z(ranges$from1, ranges$to1),
    intervals_Z(ranges$from2, ranges$to2)))

if (! exists("%within%")) {
    `%within%` <- function (a, b) standardGeneric("%within%")
}

setMethod("%within%", c(a = "numeric", b = "Intervals_full"),
          function(a, b) {  ## Vectorized over a *only*

              ## https://stackoverflow.com/a/7660073/435004
              inwhich <- function(indices, .length)
                  is.element(seq_len(.length), indices)

              Intervals_full(c(a, a), type = "Z") %>%
                  interval_included(from = b) %>%
                  c %>% inwhich(length(a))
          })

stopifnot(identical(
    c(TRUE, TRUE, FALSE),
    c(1, 0, 3) %within% intervals_Z(0, 2)))

bogons <-
    tickets %>%
    mutate(across(everything(),
                  ~ ifelse(.x %within% allowed.values, NA, .x))) %>%
    pivot_longer(everything()) %>%
    filter(! is.na(value))
```

The “ticket scanning error rate” (which is actually not an error rate
at all), is `r bogons$value %>% sum`

```{r guess.mapping, echo = FALSE}

good.tickets <-
    tickets %>%
    filter(across(everything(), ~ .x %within% allowed.values))

plausible <- ranges %>%
    mutate(summarize(
        good.tickets,
        across(everything(), function(tickets.column) {
            all.within.bounds <- function(numbers_v, from1, to1, from2, to2) {
                all((numbers_v >= from1 & numbers_v <= to1) |
                    (numbers_v >= from2 & numbers_v <= to2))
            }
            pmap_lgl(.,  function(field, from1, to1, from2, to2)
                all.within.bounds(tickets.column, from1, to1, from2, to2))
        }))) %>%
    select(-c(from1, from2, to1, to2))
```
